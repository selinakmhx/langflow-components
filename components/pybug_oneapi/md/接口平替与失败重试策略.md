# 接口平替与失败重试策略（Just One API）

> 目标：当“主接口”请求失败时，才触发“平替接口”调用；尽量减少额外请求与不必要的计费，保证可读日志与明确回退规则。
>
> 参考：Just One API 使用指南（鉴权、错误码、计费规则与延时建议）。

## 一、总体原则
- 仅在“收到失败信号”时才触发平替；绝不预先并发调用多个版本。
- 每次业务请求最多进行一次平替（主接口失败后最多再试一个平替版本），避免配额浪费。
- 对“可重试”的失败先进行一次轻量重试（例如 code=301），仍失败再考虑平替。
- 对“已计费但无内容”的返回（例如 code=201），不再调用平替，以免重复收费。
- 清晰记录：请求 URL（含首行 //request 注释）、HTTP 状态、业务 code、message、耗时、重试/平替链路。

## 二、失败判定标准（何时触发平替）
- 系统级失败（HTTP 非 200）：立即触发平替或重试（视失败类型）
  - 400 Invalid Parameters：优先检查参数；若确有版本差异导致参数不兼容，可尝试平替版本。
  - 404 Not Found：可能为路径或版本不存在，建议直接改用平替路径。
  - 超时/网络异常：先重试一次（推荐超时至少 60s），仍失败再平替。
- 业务级失败（HTTP=200，但 JSON code≠0）：按错误码分流
  - 0：成功（不触发平替）
  - 201 No Content Available：资源不存在但已计费；不触发平替，直接返回空结果。
  - 300 API INVALID：接口版本不可用；触发平替版本。
  - 301 FAILED, RETRY：允许重试一次；若仍失败再平替。
  - 302 Rate Limit Exceeded：等待后重试；一般不建议立即平替（可能同源受限）。
  - 303 Daily Quota Exceeded：停止调用，提示更换令牌/提升配额；不平替。
  - 400 Invalid Parameters（业务级）：检查参数命名与必填项；必要时再平替。
  - 500 Internal Server Error：重试一次；仍失败可平替。
  - 600 Permission Denied / 601 Insufficient Balance：停止调用，提示权限/余额问题；不平替。

## 三、平替优先级表（按我们当前环境与测试）
- 用户笔记列表
  - 主：/api/xiaohongshu/get-user-note-list/v4
  - 平替：/api/xiaohongshu/get-user-note-list/v2（若环境支持）
- 笔记详情
  - 主：/api/xiaohongshu/get-note-detail/v9（你的状态表标绿）
  - 平替：/api/xiaohongshu/get-note-detail/v7 → /api/xiaohongshu/get-note-detail/v2（逐级回退）
  - 说明：当前我们两次对 v9 返回 400；v7 为 301，v2 为 300。短期建议用 v4 列表的富字段替代展示。
- 主评论
  - 主：/api/xiaohongshu/get-note-comment/v2
  - 平替：视环境而定（若提供 v1/v3 再补充）；目前 v2 可用。
- 子评论
  - 主：/api/xiaohongshu/get-note-sub-comment/v2（已验证成功）
  - 平替：若出现 404，可尝试 /api/xiaohongshu/get-comment-replies/v2 或 /get-note-comment-replies/v2（取决于你的网关版本命名）。
- 搜索笔记
  - 主：/api/xiaohongshu/search-note/v3
  - 平替：视环境提供的其他版本而定。

> 注：不同部署或网关版本的“可用版本列表”可能不同，请以你当前的状态表为准，并按上述判定规则进行回退。

## 四、触发流程（伪代码）

```python
from typing import List, Dict, Any, Optional
import requests, json, time

class FallbackPolicy:
    # 每次业务请求最多 1 次平替；code=301 先重试 1 次
    max_fallbacks = 1
    max_retries_for_301 = 1
    timeout_seconds = 60

    @staticmethod
    def should_fallback(http_status: int, body: Optional[Dict[str, Any]]) -> bool:
        if http_status != 200:
            # 系统级错误：可触发平替
            return True
        if body is None:
            # JSON 解析失败也视为失败
            return True
        code = body.get("code")
        if code == 0:
            return False
        if code == 201:
            # 已计费但无内容：不再平替
            return False
        if code in {300, 301, 500}:
            return True
        if code in {302, 303, 600, 601}:
            # 限流/配额/权限/余额：不建议平替，交给上层处理
            return False
        # 其他错误码按需评估
        return True

    @staticmethod
    def do_request(url: str, params: Dict[str, Any]) -> (int, Optional[Dict[str, Any]]):
        try:
            r = requests.get(url, params=params, timeout=FallbackPolicy.timeout_seconds)
            http_status = r.status_code
            try:
                body = r.json()
            except Exception:
                body = None
            return http_status, body
        except Exception:
            return 0, None

    @classmethod
    def fetch_with_fallback(cls, primary_url: str, fallback_urls: List[str], params: Dict[str, Any]) -> Dict[str, Any]:
        # 第 1 次：主接口
        http_status, body = cls.do_request(primary_url, params)
        if http_status == 200 and body and body.get("code") == 301:
            # 301：先重试一次主接口
            for _ in range(cls.max_retries_for_301):
                time.sleep(0.8)
                http_status, body = cls.do_request(primary_url, params)
                if http_status == 200 and body and body.get("code") == 0:
                    return body
        if not cls.should_fallback(http_status, body):
            # 成功或不平替场景（如 201/302/303/600/601）
            return body or {"code": -1, "message": "no body"}
        # 平替：最多 1 次
        for i, fu in enumerate(fallback_urls[:cls.max_fallbacks]):
            http_status2, body2 = cls.do_request(fu, params)
            if http_status2 == 200 and body2 and body2.get("code") == 0:
                return body2
            # 若平替也失败，直接返回最后一次失败内容
            body = body2
        return body or {"code": -1, "message": "fallback failed"}
```

要点：
- 平替仅在失败时触发；成功或 201（无内容）都不回退。
- 301 允许轻量重试一次；仍失败再尝试平替版本。
- 302/303/600/601 直接返回错误，不平替（保护配额与避免误用）。
- 超时设置不低于 60s，减少“误判失败”导致的重复扣费或重复请求。

## 五、你的环境下的平替映射示例
- 见文件：`components/pybug/fallback_rules.json`
  - 描述每条接口的“主版本 + 平替版本列表”，可被你的调用器读取。

## 六、日志与可读性
- 保留首行 `//request:GET <完整 URL>` 注释。
- 第二行起格式化为多行 JSON（已在 pybug/*.pretty.json 生成）。
- 记录：HTTP 状态、业务 code、message、响应耗时、是否重试、是否平替、最终选用的版本。

## 七、配额控制建议
- 一次业务调用最多 2 次请求（主 + 1 次平替），301 重试算作一次轻量重试，不额外平替。
- 搜索与列表类接口优先使用“状态表标绿的版本”（例如 v4），减少不必要的版本切换。
- 详情接口暂时以列表富字段代替；待 v9 条件满足再接入，避免无效尝试。

---

如需，我可以把上述伪代码落地到 `xiaohongshu_aggregator.py`，以配置化读取 `fallback_rules.json` 并按策略自动回退。你点头我就接着搞，代码会保持最小侵入与详细日志。